//*******************************************************************************
//
//   Copyright (C) 2003, International Business Machines
//   Corporation and others.  All Rights Reserved.
//
//*******************************************************************************

conversion {
  Info {
    Description { "Test data for conversion" }
    LongDescription {
      "Test data for data-driven conversion tests in icu/source/test/intltest/convtest.cpp\n"
      "Run intltest conversion\n"

      "ICU callbacks are specified as strings with pairs of characters, each optional.\n"
      "Callback function - '?'=Sub '0'=Skip '.'=Stop '&'=Escape\n"
      "Callback option - a letter is passed in directly as const char * see ucnv_err.h\n"
      "Empty string: Sub callback with NULL option\n"

      "fallbacks: per-direction boolean, currently only for fromUnicode; see Jitterbug 2401\n"

      "errorCode: (empty)==zero | invalid | illegal | truncated\n"
    }
  }
  TestData {
    toUnicode {
      Headers { "charset", "bytes", "unicode", "offsets", "flush", "fallbacks", "errorCode", "callback", "invalidChars" }
      Cases {
        // surrogates in CESU-8
        { "CESU-8", :bin{ eda080eda081edb081 }, "\ud800\U00010401", :intvector{ 0, 3, 6 }, :int{1}, :int{0}, "", "", :bin{""} }
        // e080 is a partial sequence
        { "UTF-8", :bin{ 31ffe4ba8ce08061 }, "1\ufffd\u4e8c\ufffda", :intvector{ 0, 1, 2, 5, 7 }, :int{1}, :int{0}, "", "", :bin{ e080 } }
        // fbbfbfbfbf exceedes U+10ffff
        { "UTF-8", :bin{ 31fbbfbfbfbf61 }, "1\ufffda", :intvector{ 0, 1, 6 }, :int{1}, :int{0}, "", "", :bin{ fbbfbfbfbf } }

        // lead byte a2 without trail byte
        { "ibm-1363", :bin{ a2aea2 }, "\u00a1", :intvector{ 0 }, :int{1}, :int{0}, "truncated", ".", :bin{ a2 } }
        { "ibm-1363", :bin{ a2aea2 }, "\u00a1\u001a", :intvector{ 0, 2 }, :int{1}, :int{0}, "", "?", :bin{ a2 } }

        // e4b8 is a partial sequence
        { "UTF-8", :bin{ 31e4ba8ce4b8 }, "1\u4e8c", :intvector{ 0, 1 }, :int{1}, :int{0}, "truncated", ".", :bin{ e4b8 } }
        { "UTF-8", :bin{ 31e4ba8ce4b8 }, "1\u4e8c\ufffd", :intvector{ 0, 1, 4 }, :int{1}, :int{0}, "", "?", :bin{ e4b8 } }

        // simple sample, no error handling
        { "UTF-8", :bin{ 61F48FBFBF }, "a\U0010FFFF", :intvector{ 0, 1, 1 }, :int{1}, :int{0}, "", "", :bin{""} }
      }
    }

    // --------------------------------------------------------------------- ***

    fromUnicode {
      Headers { "charset", "unicode", "bytes", "offsets", "flush", "fallbacks", "errorCode", "callback", "invalidUChars" }
      Cases {
        // sub callback for supplementary code point
        { "LATIN1",  "1\U000104012", :bin{ 311a32 }, :intvector{ 0, 1, 3 }, :int{1}, :int{0}, "", "", "" }
        { "ibm-920", "1\U000104012", :bin{ 311a32 }, :intvector{ 0, 1, 3 }, :int{1}, :int{0}, "", "", "" }
        // same but not flushing
        { "LATIN1",  "1\U000104012", :bin{ 311a32 }, :intvector{ 0, 1, 3 }, :int{0}, :int{0}, "", "", "\U00010401" }
        { "ibm-920", "1\U000104012", :bin{ 311a32 }, :intvector{ 0, 1, 3 }, :int{0}, :int{0}, "", "", "\U00010401" }

        // simple sample, no error handling
        { "UTF-8", "a\U0010FFFF", :bin{ 61F48FBFBF }, :intvector{ 0, 1, 1, 1, 1 }, :int{1}, :int{0}, "", "", "" }
      }
    }
  }
}
